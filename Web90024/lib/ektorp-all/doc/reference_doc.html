<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Ektorp Reference Documentation</title><link rel="stylesheet" type="text/css" href="docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="Ektorp Reference Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="d100e1"></a>Ektorp Reference Documentation</h1></div><div><div class="author"><h3 class="author"><span class="firstname">Henrik</span> <span class="surname">Lundgren</span></h3></div></div><div><p class="releaseinfo">Version: 1.2.2</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#d100e13">1. Overview of Ektorp</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e23">Why Use Ektorp?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e65">2. Obtaining Ektorp</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e68">Maven Artifacts</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e71">Releases</a></span></dt><dt><span class="section"><a href="#d100e82">Snapshots</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e95">Download</a></span></dt><dt><span class="section"><a href="#d100e102">Sample Application</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e110">3. Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e128">HttpClient</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e229">Enabling SSL/TLS Connections</a></span></dt><dt><span class="section"><a href="#d100e238">Caching</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e243">CouchDbInstance</a></span></dt><dt><span class="section"><a href="#d100e268">CouchDbConnector</a></span></dt><dt><span class="section"><a href="#d100e291">A Minimal Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e298">4. Persistent Classes</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e313">Document Mapped as a POJO</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e336">Non-standard Method Names</a></span></dt><dt><span class="section"><a href="#d100e348">Property Level Annotations</a></span></dt><dt><span class="section"><a href="#d100e355">The CouchDbDocument Support Class</a></span></dt><dt><span class="section"><a href="#d100e368">Example of Various Mappings</a></span></dt><dt><span class="section"><a href="#d100e382">Immutable Object</a></span></dt><dt><span class="section"><a href="#d100e394">Referring Other Documents</a></span></dt><dt><span class="section"><a href="#d100e473">Decoupling Persistent Classes from Annotations</a></span></dt><dt><span class="section"><a href="#d100e488">Custom Serializer</a></span></dt><dt><span class="section"><a href="#d100e495">Custom DocumentAccessor</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e508">Document Mapped as java.util.Map</a></span></dt><dt><span class="section"><a href="#d100e515">Document Mapped as JsonNode</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e525">5. Working with Objects</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e532">Create</a></span></dt><dt><span class="section"><a href="#d100e539">Read</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e559">Special Cases</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e598">Update</a></span></dt><dt><span class="section"><a href="#d100e610">Delete</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e626">Purge Deleted Documents</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e635">Bulk Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e640">Fetch Multiple Documents With a Single Request</a></span></dt><dt><span class="section"><a href="#d100e647">Creating, Updating and Deleting Documents With a Single
        Request</a></span></dt><dt><span class="section"><a href="#d100e663">All Or Nothing</a></span></dt><dt><span class="section"><a href="#d100e671">A Note on Resource Usage in Bulk Operations</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d100e682">6. Repository Support</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e706">Out of the Box CRUD</a></span></dt><dt><span class="section"><a href="#d100e722">Standard Design Document</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e740">Standard Views</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e753">In-line View Definitions</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e781">Loading the View Definition From the classpath</a></span></dt><dt><span class="section"><a href="#d100e795">Auto Updating Views</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e811">Automatic Generation of Design Document
      and Views</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e856">Resolving Field Name Conflicts</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e868">Additional Design Document Functions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e881">7. Attachments</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e886">In-line Attachments</a></span></dt><dt><span class="section"><a href="#d100e895">Create Document and Attachment in one operation</a></span></dt><dt><span class="section"><a href="#d100e902">Add an Attachment to an Existing Document</a></span></dt><dt><span class="section"><a href="#d100e909">Fetch an Attachment</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e921">8. Querying</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e931">Query for Objects</a></span></dt><dt><span class="section"><a href="#d100e941">Scalar Queries</a></span></dt><dt><span class="section"><a href="#d100e954">View Result as Raw JSON Stream</a></span></dt><dt><span class="section"><a href="#d100e961">Complex Keys</a></span></dt><dt><span class="section"><a href="#d100e976">Pagination</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e991">PageRequest as a text link</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e1006">Queries and Cache</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1013">Enable the Cached Queries</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d100e1018">9. Change Notifications</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1039">Continuous changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1051">Managing the Feed</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e1058">Snapshots</a></span></dt></dl></dd><dt><span class="chapter"><a href="#d100e1068">10. Calling Update Handlers</a></span></dt><dt><span class="chapter"><a href="#d100e1077">11. Admin Functions</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1081">Database Replication</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1097">Initiate Replication from CouchDbInstance</a></span></dt><dt><span class="section"><a href="#d100e1115">Initiate Replication from CouchDbConnector</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d100e1136">12. Spring Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1140">XML Schema-based configuration</a></span></dt><dt><span class="section"><a href="#d100e1157">HttpClientFactoryBean</a></span></dt><dt><span class="section"><a href="#d100e1170">Bootstrapping the Database</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1183">Declaing the InitialDataLoader in the Application
        Context</a></span></dt><dt><span class="section"><a href="#d100e1190">Component Scanning</a></span></dt><dt><span class="section"><a href="#d100e1200">DataLoader</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#d100e1213">13. Android Integration</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1218">AndroidHttpClient</a></span></dt><dt><span class="section"><a href="#d100e1236">EktorpAsyncTask</a></span></dt><dt><span class="section"><a href="#d100e1251">ChangesFeedAsyncTask</a></span></dt><dt><span class="section"><a href="#d100e1265">CouchbaseViewListAdapter</a></span></dt></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>3.1. <a href="#d100e145">org.ektorp.http.StdHttpClient Config Parameters</a></dt></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Overview of Ektorp"><div class="titlepage"><div><div><h2 class="title"><a name="d100e13"></a>Chapter&nbsp;1.&nbsp;Overview of Ektorp</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e23">Why Use Ektorp?</a></span></dt></dl></div><p>Ektorp is a persistence API that uses <a class="link" href="http://couchdb.apache.org/" target="_top">CouchDB</a> as storage engine.
    The goal of Ektorp is to combine JPA* like functionality with the
    simplicity and flexibility that CouchDB provides.</p><p>* Java Persistence API</p><div class="section" title="Why Use Ektorp?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e23"></a>Why Use Ektorp?</h2></div></div></div><p>Here are some good reasons why you should consider to use Ektorp
      in your project:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Rich domain models.</em></span> With powerful
          JSON-object mapping provided by <a class="link" href="http://jackson.codehaus.org/" target="_top">Jackson</a> it is easy
          to create rich domain models.</p></li><li class="listitem"><p><span class="emphasis"><em>Schemaless comfort</em></span>. As CouchDB is
          schemaless, the database gets out of the way during application
          development. With a schemaless database, most adjustments to the
          database become transparent and automatic.</p></li><li class="listitem"><p><span class="emphasis"><em>Out-of-the-Box CRUD</em></span>. The generic
          repository support makes it trivial to create persistence
          classes.</p></li><li class="listitem"><p>Convenient management of views through annotations.</p></li><li class="listitem"><p><span class="emphasis"><em>API Coverage</em></span>. Ektorp has a broad coverage
          of the CouchDB API. You can perform most tasks like manage
          documents, perform queries, create, replicate and compact databases
          with the Ektorp API.</p></li><li class="listitem"><p><span class="emphasis"><em>Active development</em></span>. Ektorp is actively
          developed and has a growing community.</p></li><li class="listitem"><p><span class="emphasis"><em>Choice of abstraction level</em></span>. From full
          object-document mapping to raw streams, Ektorp will never stop you
          if you need to step down an abstraction level.</p></li></ul></div></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Obtaining Ektorp"><div class="titlepage"><div><div><h2 class="title"><a name="d100e65"></a>Chapter&nbsp;2.&nbsp;Obtaining Ektorp</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e68">Maven Artifacts</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e71">Releases</a></span></dt><dt><span class="section"><a href="#d100e82">Snapshots</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e95">Download</a></span></dt><dt><span class="section"><a href="#d100e102">Sample Application</a></span></dt></dl></div><div class="section" title="Maven Artifacts"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e68"></a>Maven Artifacts</h2></div></div></div><div class="section" title="Releases"><div class="titlepage"><div><div><h3 class="title"><a name="d100e71"></a>Releases</h3></div></div></div><p>Core module:</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.ektorp<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>org.ektorp<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.2.2<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><p>Spring support module:</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.ektorp<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>org.ektorp.spring<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.2.2<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre></div><div class="section" title="Snapshots"><div class="titlepage"><div><div><h3 class="title"><a name="d100e82"></a>Snapshots</h3></div></div></div><p>For the latest &amp; greatest use the snapshot:</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.ektorp<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>org.ektorp<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.3.0-SNAPSHOT<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong>


<strong class="hl-tag" style="color: #000096">&lt;dependency&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;groupId&gt;</strong>org.ektorp<strong class="hl-tag" style="color: #000096">&lt;/groupId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;artifactId&gt;</strong>org.ektorp.spring<strong class="hl-tag" style="color: #000096">&lt;/artifactId&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;version&gt;</strong>1.3.0-SNAPSHOT<strong class="hl-tag" style="color: #000096">&lt;/version&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/dependency&gt;</strong></pre><p>You can find the snapshots at
        <span class="emphasis"><em>http://oss.sonatype.org/content/repositories/snapshots/</em></span></p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;repositories&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;repository&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;id&gt;</strong>sonatype-nexus-snapshots<strong class="hl-tag" style="color: #000096">&lt;/id&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;url&gt;</strong>http://oss.sonatype.org/content/repositories/snapshots/<strong class="hl-tag" style="color: #000096">&lt;/url&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;releases&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;enabled&gt;</strong>false<strong class="hl-tag" style="color: #000096">&lt;/enabled&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/releases&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;snapshots&gt;</strong>
            <strong class="hl-tag" style="color: #000096">&lt;enabled&gt;</strong>true<strong class="hl-tag" style="color: #000096">&lt;/enabled&gt;</strong>
        <strong class="hl-tag" style="color: #000096">&lt;/snapshots&gt;</strong>
    <strong class="hl-tag" style="color: #000096">&lt;/repository&gt;</strong>
<strong class="hl-tag" style="color: #000096">&lt;/repositories&gt;</strong></pre></div></div><div class="section" title="Download"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e95"></a>Download</h2></div></div></div><p>Ektorp can be downloaded from <a class="link" href="https://github.com/helun/Ektorp/downloads" target="_top">https://github.com/helun/Ektorp/downloads</a></p></div><div class="section" title="Sample Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e102"></a>Sample Application</h2></div></div></div><p>A sample application can be downloaded from the Ektorp site. It is
      a blog webapp aimed to showcase a basic Ektorp application. You can read
      more about it in the <a class="link" href="http://ektorp.org/tutorial.html" target="_top">Ektorp
      tutorial</a>.</p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="d100e110"></a>Chapter&nbsp;3.&nbsp;Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e128">HttpClient</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e229">Enabling SSL/TLS Connections</a></span></dt><dt><span class="section"><a href="#d100e238">Caching</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e243">CouchDbInstance</a></span></dt><dt><span class="section"><a href="#d100e268">CouchDbConnector</a></span></dt><dt><span class="section"><a href="#d100e291">A Minimal Configuration</a></span></dt></dl></div><p>CouchDB is represented by two main interfaces in Ektorp:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>org.ektorp.CouchDbInstance</em></span> is the handle
        for the actual CouchDB instance you are connecting to.</p></li><li class="listitem"><p><span class="emphasis"><em>org.ektorp.CouchDbConnector</em></span> is a connection
        to a specific database residing on the instance above.</p></li></ul></div><p>So, in order to connect to a database in a CouchDB instance, you
    will need a CouchDbConnector, which needs a CouchDbInstance, which in turn
    needs a HttpClient.</p><div class="section" title="HttpClient"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e128"></a>HttpClient</h2></div></div></div><p>Ektorp's standard implementation of the HttpClient interface is
      <span class="emphasis"><em>org.ektorp.http.StdHttpClient</em></span>. It is created
      through a nested builder class:
      <span class="emphasis"><em>StdHttpClient.Builder</em></span></p><pre class="programlisting">HttpClient authenticatedHttpClient = <strong class="hl-keyword">new</strong> StdHttpClient?.Builder()
                                .url(<strong class="hl-string"><em style="color:red">"http://mychouchdbhost:5984"</em></strong>)
                                .username(<strong class="hl-string"><em style="color:red">"admin"</em></strong>)
                                .password(<strong class="hl-string"><em style="color:red">"secret"</em></strong>)
                                .build();</pre><p>StdHttpClient just wraps <a class="link" href="http://hc.apache.org/httpcomponents-client/index.html" target="_top">Apache
      HttpClient</a> and exposes the following configuration
      properties:</p><div class="table"><a name="d100e145"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;org.ektorp.http.StdHttpClient Config Parameters</b></p><div class="table-contents"><table summary="org.ektorp.http.StdHttpClient Config Parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Name</th><th align="center">Default Value</th></tr></thead><tbody><tr><td>url</td><td>http://localhost:5984</td></tr><tr><td>username</td><td>&nbsp;</td></tr><tr><td>password</td><td>&nbsp;</td></tr><tr><td>maxConnections</td><td>20</td></tr><tr><td>connectionTimeout</td><td>1000 (ms)</td></tr><tr><td>socketTimeout</td><td>10000 (ms)</td></tr><tr><td>enableSSL</td><td>false (will automatically be enabled if url begins with
              https)</td></tr><tr><td>sslSocketFactory</td><td>The JVM's ssl socket factory will be used by
              default</td></tr><tr><td>relaxedSSLSettings</td><td>false</td></tr><tr><td>caching</td><td>true</td></tr><tr><td>maxCacheEntries</td><td>1000</td></tr><tr><td>maxObjectSizeBytes</td><td>8192</td></tr><tr><td>useExpectContinue</td><td>true</td></tr><tr><td>cleanupIdleConnections</td><td>true</td></tr></tbody></table></div></div><br class="table-break"><p>If this is not enough for you, you can always create a
      <span class="emphasis"><em>org.apache.http.client.HttpClient</em></span> yourself and pass
      it as a constructor argument to the StdHttpClient.</p><div class="section" title="Enabling SSL/TLS Connections"><div class="titlepage"><div><div><h3 class="title"><a name="d100e229"></a>Enabling SSL/TLS Connections</h3></div></div></div><p>If you want the http client to connector to CouchDB with a
        SSL/TLS connection, specify an url that begins with "https" or create
        the client with the parameter enableSSL = true.</p><p>You can bring your own SSLSocketFactory if you have configured
        special trust stores etc. The factory can be specified through the
        sslSocketFactory parameter.</p><p>If you are lazy and want the trust manager to trust any host and
        certificate, relaxed SSL settings can be enabled through the
        relaxedSSLSettings parameter.</p></div><div class="section" title="Caching"><div class="titlepage"><div><div><h3 class="title"><a name="d100e238"></a>Caching</h3></div></div></div><p>Caching is enabled by default. This means that when you load a
        document from the database, it will be loaded from the http client's
        cache if it exists in the cache and the revision has not changed since
        the last access. This can speed up database access
        significantly.</p></div></div><div class="section" title="CouchDbInstance"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e243"></a>CouchDbInstance</h2></div></div></div><p>The standard implementation of the CouchDbInstance interface is
      <span class="emphasis"><em>org.ektorp.impl.StdCouchDbInstance</em></span>. This interface
      provides methods for managing databases on the connected CouchDb
      instance.</p><p>StdCouchDbInstance provides two constructors:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>StdCouchDbInstance(HttpClient
          client)</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>StdCouchDbInstance(HttpClient client,
          ObjectMapperFactory of)</em></span></p></li></ul></div><p>The second constructor allows you to bring your own
      ObjectMapperFactory if you want full control on how Jackson is
      configured.</p><p><span class="emphasis"><em>StdCouchDbInstance</em></span> is thread-safe.</p></div><div class="section" title="CouchDbConnector"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e268"></a>CouchDbConnector</h2></div></div></div><p>The standard implementation of the CouchDbConnector interface is
      <span class="emphasis"><em>org.ektorp.impl.StdCouchDbConnector</em></span>. This interface
      provides methods for manipulating documents within a specific
      database.</p><p>StdCouchDbConnector provides two constructors:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>StdCouchDbConnector(String databaseName, CouchDbInstance
          dbInstance)</p></li><li class="listitem"><p>StdCouchDbConnector(String databaseName, CouchDbInstance dbi,
          ObjectMapperFactory of)</p></li></ul></div><p>The second constructor allows you to bring your own
      ObjectMapperFactory if you want full control on how Jackson is
      configured.</p><p><span class="emphasis"><em>StdCouchDbConnector</em></span> is thread-safe.</p></div><div class="section" title="A Minimal Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e291"></a>A Minimal Configuration</h2></div></div></div><p>Here's a minimal example configuration that connects to a CouchDB
      instance on localhost:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.ektorp.*;
<strong class="hl-keyword">import</strong> org.ektorp.impl.*;
<strong class="hl-keyword">import</strong> org.ektorp.http.*;

...

HttpClient httpClient = <strong class="hl-keyword">new</strong> StdHttpClient.Builder().build()
CouchDbInstance dbInstance = <strong class="hl-keyword">new</strong> StdCouchDbInstance(httpClient);
<em class="hl-comment" style="color: silver">// if the second parameter is true, the database will be created if it doesn't exists</em>
CouchDbConnector db = dbInstance.createConnector(<strong class="hl-string"><em style="color:red">"my_first_database"</em></strong>, true);

<em class="hl-comment" style="color: silver">// go!</em>
...</pre></div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Persistent Classes"><div class="titlepage"><div><div><h2 class="title"><a name="d100e298"></a>Chapter&nbsp;4.&nbsp;Persistent Classes</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e313">Document Mapped as a POJO</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e336">Non-standard Method Names</a></span></dt><dt><span class="section"><a href="#d100e348">Property Level Annotations</a></span></dt><dt><span class="section"><a href="#d100e355">The CouchDbDocument Support Class</a></span></dt><dt><span class="section"><a href="#d100e368">Example of Various Mappings</a></span></dt><dt><span class="section"><a href="#d100e382">Immutable Object</a></span></dt><dt><span class="section"><a href="#d100e394">Referring Other Documents</a></span></dt><dt><span class="section"><a href="#d100e473">Decoupling Persistent Classes from Annotations</a></span></dt><dt><span class="section"><a href="#d100e488">Custom Serializer</a></span></dt><dt><span class="section"><a href="#d100e495">Custom DocumentAccessor</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e508">Document Mapped as java.util.Map</a></span></dt><dt><span class="section"><a href="#d100e515">Document Mapped as JsonNode</a></span></dt></dl></div><p>Ektorp can work with CouchDB documents in three different
    styles:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>POJO (Plain Old Java Object)</p></li><li class="listitem"><p>java.util.Map&lt;String, Object&gt;</p></li><li class="listitem"><p>JsonNode - provides DOM-style access to JSON-documents</p></li></ul></div><div class="section" title="Document Mapped as a POJO"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e313"></a>Document Mapped as a POJO</h2></div></div></div><p>Ektorp is mainly build for persisting rich domain classes in
      CouchDB much like classing ORM tools such as Hibernate. This is achieved
      by using the powerful object mapping features provided by the Jackson
      JSON library.</p><p>Your classes need to fulfill two requirements in order to be
      compatible with Ektorp:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The class must be able to be serialized and deserialized
          through Jackson's ObjectMapper.</p></li><li class="listitem"><p>The class must define an id field and a revision field through
          the annotations <span class="emphasis"><em>@JsonProperty("_id")</em></span> and
          <span class="emphasis"><em>@JsonProperty("_rev").</em></span></p></li></ol></div><p>Here's an example class:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.codehaus.jackson.annotate.*;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sofa {

        
        <strong class="hl-keyword">private</strong> String id;
        <strong class="hl-keyword">private</strong> String revision;
        <strong class="hl-keyword">private</strong> String color;
        
        <em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
        <strong class="hl-keyword">public</strong> String getId() {
                <strong class="hl-keyword">return</strong> id;
        }

        <em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setId(String s) {
                id = s;
        }

        <em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em>
        <strong class="hl-keyword">public</strong> String getRevision() {
                <strong class="hl-keyword">return</strong> revision;
        }

        <em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setRevision(String s) {
                revision = s;
        }

        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setColor(String s) {
                color = s;
        }
        
        <strong class="hl-keyword">public</strong> String getColor() {
                <strong class="hl-keyword">return</strong> color;
        }
}</pre><div class="section" title="Non-standard Method Names"><div class="titlepage"><div><div><h3 class="title"><a name="d100e336"></a>Non-standard Method Names</h3></div></div></div><p>It is possible to use other method names than shown above as
        long as the method is annotated with
        <span class="emphasis"><em>@JsonProperty</em></span>:</p><pre class="programlisting">...

<em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
<strong class="hl-keyword">public</strong> String getIdentifikator() {
    <strong class="hl-keyword">return</strong> identifikator;
}

...</pre><p>Methods can have any visibility; public, protected, default or
        private.</p></div><div class="section" title="Property Level Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="d100e348"></a>Property Level Annotations</h3></div></div></div><p>It is also possible to annotate the fields directly:</p><pre class="programlisting">...

<em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
<strong class="hl-keyword">private</strong> String id;

<em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em>
<strong class="hl-keyword">private</strong> String rev;

...</pre></div><div class="section" title="The CouchDbDocument Support Class"><div class="titlepage"><div><div><h3 class="title"><a name="d100e355"></a>The CouchDbDocument Support Class</h3></div></div></div><p>If you don't mind dependencies on Ektorp in your domain classes
        you can extend the class
        <span class="emphasis"><em>org.ektorp.support.CouchDbDocument</em></span></p><p>CouchDbDocument already has mappings defined for id, revision
        and also for attachment stubs.</p><p>Here's how the Sofa class looks like when extending
        CouchDbDocument:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.ektorp.support.CouchDbDocument;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sofa <strong class="hl-keyword">extends</strong> CouchDbDocument{

        <strong class="hl-keyword">private</strong> String color;
        
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setColor(String s) {
                color = s;
        }
        
        <strong class="hl-keyword">public</strong> String getColor() {
                <strong class="hl-keyword">return</strong> color;
        }
}</pre></div><div class="section" title="Example of Various Mappings"><div class="titlepage"><div><div><h3 class="title"><a name="d100e368"></a>Example of Various Mappings</h3></div></div></div><p>Here is an example object that showcases various
        mappings:</p><pre class="programlisting"><strong class="hl-keyword">package</strong> org.ektorp.sample;

<strong class="hl-keyword">import</strong> java.util.*;

<strong class="hl-keyword">import</strong> org.codehaus.jackson.annotate.*;
<strong class="hl-keyword">import</strong> org.ektorp.*;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sofa <strong class="hl-keyword">extends</strong> CouchDbDocument {

        <strong class="hl-keyword">private</strong> String color;
        <strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> seats;
        <strong class="hl-keyword">private</strong> Date dateCreated;
        <strong class="hl-keyword">private</strong> List&lt;String&gt; imageURLs;
        <strong class="hl-keyword">private</strong> Map&lt;String, Pillow&gt; pillows;
        
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setColor(String s) {
                <strong class="hl-keyword">this</strong>.color = s;
        }
        
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getSeats() {
                <strong class="hl-keyword">return</strong> seats;
        }
        
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setSeats(<strong class="hl-keyword">int</strong> i) {
                <strong class="hl-keyword">this</strong>.seats = i;
        }
        
        <strong class="hl-keyword">public</strong> String getColor() {
                <strong class="hl-keyword">return</strong> color;
        }
        
        <strong class="hl-keyword">public</strong> List&lt;String&gt; getImageURLs() {
                <strong class="hl-keyword">return</strong> imageURLs;
        }
        
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setImageURLs(List&lt;String&gt; imageURLs) {
                <strong class="hl-keyword">this</strong>.imageURLs = imageURLs;
        }
        
        <em><span class="hl-annotation" style="color: gray">@JsonIgnore</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getNumberOfImages() {
                <strong class="hl-keyword">return</strong> imageURLs != null ? imageURLs.size() : <span class="hl-number">0</span>;
        }
        
        <strong class="hl-keyword">public</strong> Map&lt;String, Pillow&gt; getPillows() {
                <strong class="hl-keyword">return</strong> pillows;
        }
        
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setPillows(Map&lt;String, Pillow&gt; pillows) {
                <strong class="hl-keyword">this</strong>.pillows = pillows;
        }
        
        <em><span class="hl-annotation" style="color: gray">@JsonProperty("date_created")</span></em>
        <strong class="hl-keyword">public</strong> Date getDateCreated() {
                <strong class="hl-keyword">return</strong> dateCreated;
        }
        
        <em><span class="hl-annotation" style="color: gray">@JsonProperty("date_created")</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setDateCreated(Date dateCreated) {
                <strong class="hl-keyword">this</strong>.dateCreated = dateCreated;
        }
}</pre><p>As you can see, most properties does not require any special
        mappings. The @JsonProperty annotation are used to map a property to a
        different name than the property name.</p><p>In order to suppress a property <span class="emphasis"><em>@JsonIgnore</em></span>
        is used.</p></div><div class="section" title="Immutable Object"><div class="titlepage"><div><div><h3 class="title"><a name="d100e382"></a>Immutable Object</h3></div></div></div><p>It is possible to map immutable objects:</p><pre class="programlisting"><strong class="hl-keyword">package</strong> org.ektorp.sample;

<strong class="hl-keyword">import</strong> org.codehaus.jackson.annotate.*;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Pillow {
        
        <strong class="hl-keyword">public</strong> enum Softness {SOFT, MEDIUM, FIRM}
        
        <strong class="hl-keyword">private</strong> <strong class="hl-keyword">final</strong> Softness softness;
        
        <em><span class="hl-annotation" style="color: gray">@JsonCreator</span></em>
        <strong class="hl-keyword">public</strong> Pillow(<em><span class="hl-annotation" style="color: gray">@JsonProperty("softness")</span></em> Softness s) {
            softness = s;
        }
        
        <strong class="hl-keyword">public</strong> Softness getSoftness() {
            <strong class="hl-keyword">return</strong> softness;
        }
}</pre><p>The constructor is annotated with
        <span class="emphasis"><em>@JsonCreator</em></span> and the properties has to be
        specified with @JsonProperty</p></div><div class="section" title="Referring Other Documents"><div class="titlepage"><div><div><h3 class="title"><a name="d100e394"></a>Referring Other Documents</h3></div></div></div><p>An embedded collection may need to be externalized due to size
        or to reduce update congestion.</p><p>Ektorp provides support for this through the @DocumentReferences
        annotation.</p><p>Fields annotated with @DocumentReferences will have their
        children elements stored in separate documents. Only collections that
        implement java.util.Set are supported.</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> BlogPost {

    <em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
    <strong class="hl-keyword">private</strong> String id;

    <em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em>
    <strong class="hl-keyword">private</strong> String rev;

    <em><span class="hl-annotation" style="color: gray">@DocumentReferences(backReference = "blogPostId", fetch = FetchType.LAZY, descendingSortOrder = true, orderBy = "dateCreated")</span></em>
    <strong class="hl-keyword">private</strong> Set&lt;Comment&gt; comments;

...</pre><p>The backReference parameter is required and must name the field
        in the child document that contains the id of the parent
        document.</p><p>The fetch strategy if @DocumentReferences collections may be
        lazy or eager. If set to lazy, the collection will be populated in
        entirety when the collection is first touched. Eager setting will
        cause the collection to be populated at the same time as it
        parent.</p><p>The sort order of the loaded collection may be specified by the
        orderBy parameter. The parameter must refer to a field in the child
        docs.</p><div class="section" title="Transitive Persistence"><div class="titlepage"><div><div><h4 class="title"><a name="d100e411"></a>Transitive Persistence</h4></div></div></div><p>If an element is added to a Set annotated with
          @DocumentReferences the element will be stored transparently when
          the parent document is updated.</p><p>Removing an element from the collection will cause its
          deletion from the database when the parent document is
          updated.</p><p>The cascade behaviour can be controlled through the cascade
          parameter in @DocumentReferences. There are four cascade
          types:</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>ALL</td><td>All operations are cascaded to the child
                  documents.</td></tr><tr><td>SAVE_UPDATE</td><td>Cascades the create and update operations when
                  create(), update(), executeBulk() or executeAllOrNothing()
                  is called.</td></tr><tr><td>DELETE</td><td>Cascades the remove operation to associated entities
                  if delete(), executeBulk() or executeAllOrNothing() is
                  called.</td></tr><tr><td>NONE (default)</td><td>No operation is cascaded to the child
                  documents.</td></tr></tbody></table></div><div class="section" title="Recommendation"><div class="titlepage"><div><div><h5 class="title"><a name="d100e443"></a>Recommendation</h5></div></div></div><p>The cascade type you choose can have a large inpact on how
            your application behaves. If you have moved the collection to
            extenal documents in order to avoid update congestion, then
            cascade type NONE is probably the best option as this will
            minimize conflicts.</p></div><div class="section" title="Limitations"><div class="titlepage"><div><div><h5 class="title"><a name="d100e448"></a>Limitations</h5></div></div></div><p>In Ektorp 1.1.0 the cascade logic for updates is quite crude
            and will cause updates of all elements, regardless if the have
            changed or not. This behaviour might change in future
            releases.</p><p>If the parent document is deleted the child docuements will
            not be deleted automatically.</p></div></div><div class="section" title="Supporting Views"><div class="titlepage"><div><div><h4 class="title"><a name="d100e455"></a>Supporting Views</h4></div></div></div><p>Allthough the document references are managed transparently it
          can be interesting to know that the relations between parent and
          child documents are managed by views that are automatically
          generated by Ektorp (unless explicitly specified). These views are
          put in the <a class="link" href="std_design_doc" target="_top">Standard Design
          Document</a> and are named according to the following naming
          convention: ektorp_docrefs_[fieldName].</p><p>Supporting views are generated in conjunction with the view
          generation functionaly provided by the repository support in Ektorp,
          see <a class="link" href="auto_view_gen" target="_top">chapter 6</a>.</p></div><div class="section" title="Only One-to-Many relations are supported"><div class="titlepage"><div><div><h4 class="title"><a name="d100e468"></a>Only One-to-Many relations are supported</h4></div></div></div><p>The views can only support one backreference to one parent,
          Many-to-Many relations are hence not supported.</p></div></div><div class="section" title="Decoupling Persistent Classes from Annotations"><div class="titlepage"><div><div><h3 class="title"><a name="d100e473"></a>Decoupling Persistent Classes from Annotations</h3></div></div></div><p>If you don't want your classes to have external dependencies or
        if you can't modify them for other reasons, you can register a mix-in
        class (or interface) that provides the mapping information to the JSON
        processor. In order to do this you must bring your own instance of
        org.codehaus.jackson.map.ObjectMapper:</p><pre class="programlisting">ObjectMapper myMapper = <strong class="hl-keyword">new</strong> ObjectMapper();

myMapper.getSerializationConfig().addMixInAnnotations(Target.<strong class="hl-keyword">class</strong>, MixIn.<strong class="hl-keyword">class</strong>);
myMapper.getDeserializationConfig().addMixInAnnotations(Target.<strong class="hl-keyword">class</strong>, MixIn.<strong class="hl-keyword">class</strong>);


CouchDbConnector db = <strong class="hl-keyword">new</strong> StdCouchDbConnector(<strong class="hl-string"><em style="color:red">"myDBName"</em></strong>, dbInstance, myMapper);</pre><p>The mix-in class is just an abstract class that provides the
        annotations for your target class:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@JsonSerialize(include = Inclusion.NON_NULL)</span></em>
<strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">class</strong> MixIn

  <em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">int</strong> getFoo(); <em class="hl-comment" style="color: silver">// rename property</em>
  <em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">int</strong> getBar(); <em class="hl-comment" style="color: silver">// rename property</em>
  <em><span class="hl-annotation" style="color: gray">@JsonIgnore</span></em> <strong class="hl-keyword">int</strong> getSize(); <em class="hl-comment" style="color: silver">// we don't need it!</em>
  
}</pre><p>Read more about mix-ins in the <a class="link" href="http://wiki.fasterxml.com/JacksonMixInAnnotations" target="_top">Jackson
        Documentation.</a></p></div><div class="section" title="Custom Serializer"><div class="titlepage"><div><div><h3 class="title"><a name="d100e488"></a>Custom Serializer</h3></div></div></div><p>If you have special needs and want to have complete control of
        the serialization you can register a custom serializer for your
        class:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@JsonSerailize(using = MySpecialType.Serializer.class)</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySpecialDocument {

    String id;
    String revision;
    
    ... rest of <strong class="hl-keyword">class</strong> goes here ...
    
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> Serializer <strong class="hl-keyword">extends</strong> JsonSerializer&lt;MySpecialType&gt; {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> serialize(MySpecialType value, JsonGenerator jgen,
                SerializerProvider provider) <strong class="hl-keyword">throws</strong> IOException,
                JsonProcessingException {
            jgen.writeStartObject();
            jgen.writeStringField(<strong class="hl-string"><em style="color:red">"_id"</em></strong>, value.id);
            jgen.writeStringField(<strong class="hl-string"><em style="color:red">"_rev"</em></strong>, value.revision);
            ...
            etc etc
            ...
            jgen.writeEndObject();
        }
        
    }
}</pre></div><div class="section" title="Custom DocumentAccessor"><div class="titlepage"><div><div><h3 class="title"><a name="d100e495"></a>Custom DocumentAccessor</h3></div></div></div><p>Ektorp has to know how to access the id and revision properties
        in the types it is working with. For most types that are annotated or
        follow the naming convention this works out of the box. But if you are
        using a an exotic type, a custom serializer or mix-ins Ektorp might
        not be able to figure out how to access these properties.</p><p>In this case you can create and register a custom document
        accessor:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.ektorp.util.DocumentAccessor;
<strong class="hl-keyword">import</strong> org.ektorp.util.Documents;

<strong class="hl-keyword">class</strong> MyDocumentAccessor <strong class="hl-keyword">implements</strong> DocumentAccessor {
    <strong class="hl-tag" style="color: blue">/**
    * @return true if document type's id field can be mutated.
    */</strong>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> hasIdMutator() {
        <strong class="hl-keyword">return</strong> true;
    }

    <strong class="hl-keyword">public</strong> String getId(Object o) {
        <strong class="hl-keyword">return</strong> cast(o).foo;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setId(Object o, String id) {
        cast(o).foo = rev;
    }

    <strong class="hl-keyword">public</strong> String getRevision(Object o) {
        <strong class="hl-keyword">return</strong> cast(o).bar;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setRevision(Object o, String rev) {
        cast(o).bar = rev;
    }

    <strong class="hl-keyword">private</strong> MyType cast(Object o) {
        <strong class="hl-keyword">return</strong> (MyType) o;
    }

}</pre><p>And register the new accessor with Ektorp:</p><pre class="programlisting">Documents.registerAccessor(MyType.<strong class="hl-keyword">class</strong>, <strong class="hl-keyword">new</strong> MyDocumentAccessor());

<em class="hl-comment" style="color: silver">// here's a Junit snippet you can use to test your accessor:</em>
MyType myType = <strong class="hl-keyword">new</strong> MyType();
Documents.setId(myType, <strong class="hl-string"><em style="color:red">"my_id"</em></strong>);
assertEquals(<strong class="hl-string"><em style="color:red">"my_id"</em></strong>, Documents.getId(myType));
assertTrue(Documents.isNew(myType));</pre></div></div><div class="section" title="Document Mapped as java.util.Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e508"></a>Document Mapped as java.util.Map</h2></div></div></div><p>It is possible to read and write documents mapped as
      java.util.Map&lt;String, Object&gt;. This is convenient if you have
      documents that have a simple structure and a small number of
      fields.</p><pre class="programlisting">    
    List&lt;String&gt; countries = ...
    Map&lt;String, List&lt;String&gt;&gt; majorCitiesByCountry = ...
    
    Map&lt;String, Object&gt; referenceData = <strong class="hl-keyword">new</strong> HashMap&lt;String, Object&gt;();
    referenceData.put(<strong class="hl-string"><em style="color:red">"_id"</em></strong>, <strong class="hl-string"><em style="color:red">"referenceData"</em></strong>);
    referenceData.put(<strong class="hl-string"><em style="color:red">"countries"</em></strong>, countries);
    referenceData.put(<strong class="hl-string"><em style="color:red">"majorCitiesByCountry"</em></strong>, majorCitiesByCountry);
    
    db.create(referenceData);

    Map&lt;String, Object&gt; referenceData_<span class="hl-number">2</span> = db.get(Map.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"referenceData"</em></strong>)
    ...</pre></div><div class="section" title="Document Mapped as JsonNode"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e515"></a>Document Mapped as JsonNode</h2></div></div></div><p>If you like to work with your documents in a DOM-style manner your
      can use <span class="emphasis"><em>org.codehaus.jackson.JsonNode</em></span>. This is
      useful if you want to modify documents without creating explicit Java
      types for them. JsonNode is more powerful than java.util.Map when it
      comes to traversing and modifying the document.</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.ektorp.*;
<strong class="hl-keyword">import</strong> org.codehaus.jackson.*;
<strong class="hl-keyword">import</strong> org.codehaus.jackson.node.*;

    ...

    JsonNode doc = db.get(JsonNode.<strong class="hl-keyword">class</strong>, <strong class="hl-string"><em style="color:red">"myDoc"</em></strong>);
        
    JsonNode address = doc.findPath(<strong class="hl-string"><em style="color:red">"address"</em></strong>);
    <strong class="hl-keyword">if</strong> (address.isObject()) {
        ObjectNode a = (ObjectNode) address;
        a.put(<strong class="hl-string"><em style="color:red">"city"</em></strong>, <strong class="hl-string"><em style="color:red">"Stockholm"</em></strong>);
    }
        
    db.update(doc);</pre></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Working with Objects"><div class="titlepage"><div><div><h2 class="title"><a name="d100e525"></a>Chapter&nbsp;5.&nbsp;Working with Objects</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e532">Create</a></span></dt><dt><span class="section"><a href="#d100e539">Read</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e559">Special Cases</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e598">Update</a></span></dt><dt><span class="section"><a href="#d100e610">Delete</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e626">Purge Deleted Documents</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e635">Bulk Operations</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e640">Fetch Multiple Documents With a Single Request</a></span></dt><dt><span class="section"><a href="#d100e647">Creating, Updating and Deleting Documents With a Single
        Request</a></span></dt><dt><span class="section"><a href="#d100e663">All Or Nothing</a></span></dt><dt><span class="section"><a href="#d100e671">A Note on Resource Usage in Bulk Operations</a></span></dt></dl></dd></dl></div><p>Basic CRUD (Create, Read, Update and Delete) operations are
    straightforward in Ektorp.</p><p>The easiest way to create a repository is to extend the class
    CouchDbRepositorySupport. The class provides all CRUD methods out of the
    box and has support methods for writing terse finder methods.</p><div class="section" title="Create"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e532"></a>Create</h2></div></div></div><pre class="programlisting">Sofa sofa = ...

CouchDbConnector db = ...
db.create(sofa);

<em class="hl-comment" style="color: silver">// both id and revision will be set after create</em>
String id = sofa.getId();
String revision = sofa.getRevision();</pre><p>If the object being created does not have an id set, CouchDB will
      generate one. Both id and revision will be set after the create
      operation.</p></div><div class="section" title="Read"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e539"></a>Read</h2></div></div></div><p>Get the latest revision of a document from the database:</p><pre class="programlisting">String id = ...
Sofa sofa = db.get(Sofa.<strong class="hl-keyword">class</strong>, id);</pre><p>If the desired document does not exists in the database an
      <span class="emphasis"><em>org.ektorp.DocumentNotFoundException</em></span> is
      thrown.</p><p>If you need to fetch a specific revision:</p><pre class="programlisting">String id = ...
String rev = ...
Sofa sofa = db.get(Sofa.<strong class="hl-keyword">class</strong>, id, rev);</pre><p>Read a document as a raw stream:</p><pre class="programlisting">String id = ...
InputStream doc = db.getAsStream(id);

InputStream olderRev = db.getAsStream(id, rev);</pre><div class="section" title="Special Cases"><div class="titlepage"><div><div><h3 class="title"><a name="d100e559"></a>Special Cases</h3></div></div></div><p>All get methods in CouchDbConnector has a variant that takes a
        <span class="emphasis"><em>org.ektorp.Options</em></span> argument. Options is used for
        special cases when you need to load a document with a specific
        revision, conflict markers etc.</p><div class="section" title="Read a Specific Revision"><div class="titlepage"><div><div><h4 class="title"><a name="d100e567"></a>Read a Specific Revision</h4></div></div></div><p><em class="parameter"><code>Retrieve a specific revision of the
          document.</code></em></p><pre class="programlisting">String id = ...
String rev = ...
Options options = <strong class="hl-keyword">new</strong> Options().revision(rev);
Sofa sofa = db.get(Sofa.<strong class="hl-keyword">class</strong>, id, options);</pre></div><div class="section" title="Include Conflicts"><div class="titlepage"><div><div><h4 class="title"><a name="d100e575"></a>Include Conflicts</h4></div></div></div><p>The loaded doc will include the special field '_conflicts'
          that contains all the conflicting revisions of the document.</p><pre class="programlisting">String id = ...
Options options = <strong class="hl-keyword">new</strong> Options().includeConflicts();
Sofa sofa = db.get(Sofa.<strong class="hl-keyword">class</strong>, id, options);</pre><p></p></div><div class="section" title="Include All Revisions"><div class="titlepage"><div><div><h4 class="title"><a name="d100e583"></a>Include All Revisions</h4></div></div></div><p>The loaded doc will include the special field '_revisions'
          that describes all document revisions that exists in the
          database.</p><pre class="programlisting">String id = ...
Options options = <strong class="hl-keyword">new</strong> Options().includeRevisions();
Sofa sofa = db.get(Sofa.<strong class="hl-keyword">class</strong>, id, options);</pre></div><div class="section" title="Add Arbitrary Parameters to the Request"><div class="titlepage"><div><div><h4 class="title"><a name="d100e590"></a>Add Arbitrary Parameters to the Request</h4></div></div></div><p><em class="parameter"><code>It is possible to add arbitrary parameters to the
          database request.</code></em></p><pre class="programlisting">String id = ...
Options options = <strong class="hl-keyword">new</strong> Options().param(<strong class="hl-string"><em style="color:red">"paramName"</em></strong>,<strong class="hl-string"><em style="color:red">"paramValue"</em></strong>);
Sofa sofa = db.get(Sofa.<strong class="hl-keyword">class</strong>, id, options);</pre></div></div></div><div class="section" title="Update"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e598"></a>Update</h2></div></div></div><pre class="programlisting">Sofa sofa = ...
db.update(sofa)
<em class="hl-comment" style="color: silver">// revision will be updated after update</em>
sofa.getRevision();</pre><p>If the there exists a newer revision of the document in the
      database, an <span class="emphasis"><em>org.ektorp.UpdateConflictException</em></span> is
      thrown.</p><p>Note that calling update with an object that has an empty id field
      will create a new document in the database.</p></div><div class="section" title="Delete"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e610"></a>Delete</h2></div></div></div><p>Both the id and revision of an object is required in order to
      delete it:</p><pre class="programlisting">String id = ...
String revision = ...
db.delete(id, revision):</pre><p>If the there exists a newer revision of the document in the
      database, an <span class="emphasis"><em>org.ektorp.UpdateConflictException</em></span> is
      thrown.</p><p>As a convenience, a whole object can also be passed as an
      argument:</p><pre class="programlisting">Sofa sofa = ...
db.delete(sofa)</pre><div class="section" title="Purge Deleted Documents"><div class="titlepage"><div><div><h3 class="title"><a name="d100e626"></a>Purge Deleted Documents</h3></div></div></div><p>Since the database retains references to deleted documents you
        may need to permanently remove those references. This can be achieved
        through a purge operation:</p><pre class="programlisting">// the map contains revisions by doc id to purge
Map&lt;String,List&lt;String&gt;&gt; revisionsToPurge = ...
PurgeResult result = db.purge(revisionsToPurge);
</pre><p><em class="parameter"><code>Note that purging docs from the database is not
        part of a normal use case and should only be considered if you need to
        free up disk space.</code></em></p></div></div><div class="section" title="Bulk Operations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e635"></a>Bulk Operations</h2></div></div></div><p>Ektorp provides full support for the bulk document operations
      available in CouchDB.</p><div class="section" title="Fetch Multiple Documents With a Single Request"><div class="titlepage"><div><div><h3 class="title"><a name="d100e640"></a>Fetch Multiple Documents With a Single Request</h3></div></div></div><p>Loading multiple documents in one call is performed through the
        queryView API. The difference from regular view queries is that
        allDocs() is called instead of defining a design document.</p><pre class="programlisting">List&lt;String&gt; docIds = ...

ViewQuery q = <strong class="hl-keyword">new</strong> ViewQuery()
                      .allDocs()
                      .includeDocs(true)
                      .keys(docIds);

List&lt;Sofa&gt; bulkLoaded = db.queryView(q, Sofa.<strong class="hl-keyword">class</strong>);</pre></div><div class="section" title="Creating, Updating and Deleting Documents With a Single Request"><div class="titlepage"><div><div><h3 class="title"><a name="d100e647"></a>Creating, Updating and Deleting Documents With a Single
        Request</h3></div></div></div><p>All other bulk operations are performed through the same methods
        in <span class="emphasis"><em>CouchDbConnector</em></span>:</p><pre class="programlisting">List&lt;DocumentOperationResult&gt; executeBulk(Collection&lt;?&gt; objects);

List&lt;DocumentOperationResult&gt; executeAllOrNothing(Collection&lt;?&gt; objects);</pre><p>If a new object is added to the objects list it will be created
        in the database. If an existing object is added, (revision being not
        null) it will be updated.</p><p>In order to delete an object, add a instance of
        org.ektorp.BulkDeleteDocument the the bulk list:</p><pre class="programlisting">List&lt;Object&gt; bulkDocs = ...
Sofa toBeDeleted = ...
        
bulkDocs.add(BulkDeleteDocument.of(toBeDeleted));
        
db.executeBulk(bulkDocs);
</pre></div><div class="section" title="All Or Nothing"><div class="titlepage"><div><div><h3 class="title"><a name="d100e663"></a>All Or Nothing</h3></div></div></div><p>The method <span class="emphasis"><em>executeAllOrNothing</em></span> has
        unsurprisingly all-or-nothing semantics. In the case of a failure
        during the bulk operation, when the database restarts either all the
        changes will have been saved or none of them. However, it does not do
        any conflict checking, so the documents will be committed even if this
        creates conflicts.</p></div><div class="section" title="A Note on Resource Usage in Bulk Operations"><div class="titlepage"><div><div><h3 class="title"><a name="d100e671"></a>A Note on Resource Usage in Bulk Operations</h3></div></div></div><p>Ektorp will create threads for writing bulk documents to the
        database. The threads are named <span class="emphasis"><em>"ektorp-doc-writer-[thread
        count]"</em></span>. The thread pool used is a
        <span class="emphasis"><em>java.util.concurrent.Executors.newCachedThreadPool()</em></span>.
        Unused threads will die after 60 seconds.</p></div></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;Repository Support"><div class="titlepage"><div><div><h2 class="title"><a name="d100e682"></a>Chapter&nbsp;6.&nbsp;Repository Support</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e706">Out of the Box CRUD</a></span></dt><dt><span class="section"><a href="#d100e722">Standard Design Document</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e740">Standard Views</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e753">In-line View Definitions</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e781">Loading the View Definition From the classpath</a></span></dt><dt><span class="section"><a href="#d100e795">Auto Updating Views</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e811">Automatic Generation of Design Document
      and Views</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e856">Resolving Field Name Conflicts</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e868">Additional Design Document Functions</a></span></dt></dl></div><p>The Repository Support in Ektorp is aimed to reduce the amount of
    repetitive code in repositories and to facilitate the management of the
    design documents that define the views for the documents in
    CouchDB.</p><p>Ektorp provides a repository base class
    <span class="emphasis"><em>org.ektorp.support.CouchDbRepositorySupport</em></span> that has
    a number of features:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Out of the box CRUD.</p></li><li class="listitem"><p>Automatic view generation.</p></li><li class="listitem"><p>View management.</p></li><li class="listitem"><p>Support methods for easier querying.</p></li></ul></div><p></p><div class="section" title="Out of the Box CRUD"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e706"></a>Out of the Box CRUD</h2></div></div></div><p>Here is a minimal repository based on
      <span class="emphasis"><em>org.ektorp.support.CouchDbRepositorySupport:</em></span></p><pre class="programlisting"><strong class="hl-keyword">package</strong> org.ektorp.sample;

<strong class="hl-keyword">import</strong> java.util.*;
<strong class="hl-keyword">import</strong> org.ektorp.*;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SofaRepository <strong class="hl-keyword">extends</strong> CouchDbRepositorySupport&lt;Sofa&gt; {

        <strong class="hl-keyword">public</strong> SofaRepository(CouchDbConnector db) {
                <strong class="hl-keyword">super</strong>(Sofa.<strong class="hl-keyword">class</strong>, db);
        }

        <strong class="hl-keyword">public</strong> List&lt;Sofa&gt; findByColor(String color) {
                <strong class="hl-keyword">return</strong> queryView(<strong class="hl-string"><em style="color:red">"by_color"</em></strong>, color);
        }
}</pre><p>This repository above doesn't look like much but
      <span class="emphasis"><em>CouchDbRepositorySupport</em></span> has provided the following
      methods to the SofaRepository:</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> add(Sofa entity);
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> update(Sofa entity);
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> remove(Sofa entity);
<strong class="hl-keyword">public</strong> Sofa get(String id);
<strong class="hl-keyword">public</strong> Sofa get(String id, String rev);
<strong class="hl-keyword">public</strong> List&lt;T&gt; getAll();
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> contains(String docId);</pre></div><div class="section" title="Standard Design Document"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e722"></a>Standard Design Document</h2></div></div></div><p>When using support methods like <span class="emphasis"><em>queryView</em></span> the
      underlying code assumes that the database contains a design document
      with an id adhering to the naming convention:</p><p><span class="emphasis"><em>_design/[repository type simple name]</em></span></p><p>e.g. the repository in the previous section expects that the
      document _design/Sofa exists in the database.</p><p>Calling <span class="emphasis"><em>queryView</em></span> without the standard design
      document defined will cause an exception to be thrown.</p><div class="section" title="Standard Views"><div class="titlepage"><div><div><h3 class="title"><a name="d100e740"></a>Standard Views</h3></div></div></div><p>The method getAll will try to query the view "all" in the
        standard design document in order to get a list of all document ids
        that are handled by the repository.</p><p>If the "all" view is missing, all documents (except design
        documents) will be loaded. This means that you cannot mix document
        types in the same database without the "all" view. Another problem
        with a missing "all" view is that concurrent deletes of documents
        while documents are loaded may cause an DbAccessException.</p><p>It is strongly recommended that the all view is defined in a
        production enviroment.</p><p>Here is an example "all" view:</p><pre class="programlisting">[{<strong class="hl-string"><em style="color:red">"_id"</em></strong>:<strong class="hl-string"><em style="color:red">"_design/Sofa"</em></strong>,
    <strong class="hl-string"><em style="color:red">"views"</em></strong>:{
        <strong class="hl-string"><em style="color:red">"all"</em></strong>: {<strong class="hl-string"><em style="color:red">"map"</em></strong>: <strong class="hl-string"><em style="color:red">"function(doc) { if (doc.type = 'Sofa' ) emit( null, doc._id ) } "</em></strong>}
     }
}]</pre></div></div><div class="section" title="In-line View Definitions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e753"></a>In-line View Definitions</h2></div></div></div><p>Repositories based on CouchDbRepositorySupport may define the
      views used by the repository through annotations in the repository
      class.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@View( name = "all", map = "function(doc) { if (doc.type == 'Sofa' ) emit( null, doc._id )}")</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SofaRepository <strong class="hl-keyword">extends</strong> CouchDbRepositorySupport&lt;Sofa&gt; {

    <em><span class="hl-annotation" style="color: gray">@View( name = "avg_sofa_size", map = "function(doc) {...}", reduce = "function(doc) {...}")</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getAverageSofaSize() {
        ViewResult r = db.queryView(createQuery(<strong class="hl-string"><em style="color:red">"avg_sofa_size"</em></strong>));
        <strong class="hl-keyword">return</strong> r.getRows().get(<span class="hl-number">0</span>).getValueAsInt();
    }

}</pre><p>If you have many view definition you can group them with the
      @Views annotation:</p><pre class="programlisting">@Views({
    @View(name = "view_1", map = "function(doc) { ... }"),
    @View(name = "view_2", map = "function(doc) { ... }"),
    @View(name = "view_3", map = "function(doc) { ... }")
    })
public class MyRepository {
    ...</pre><p><span class="emphasis"><em>@View</em></span> and <span class="emphasis"><em>@Views</em></span> and can
      be defined at class level or at method level.</p><p>View creation is triggered by calling the method:
      <span class="emphasis"><em>initStandardDesignDocument</em></span> in
      <span class="emphasis"><em>CouchDbRepositorySupport</em></span>.</p><p>If the standard design document doesn't exists, it will be
      created.</p><div class="section" title="Loading the View Definition From the classpath"><div class="titlepage"><div><div><h3 class="title"><a name="d100e781"></a>Loading the View Definition From the classpath</h3></div></div></div><p>Non-trivial views are best stored in a separate files. By
        specifying the "classpath:" prefix in the map or reduce parameters,
        followed by the path to a file in the classpath, the functions can be
        loaded from the classpath. The path is relative to the class annotated
        by this annotation. If the file myMapFunction.js is in the same
        directory as the repository this parameter should be set to
        <span class="emphasis"><em>"myMapFunction.js"</em></span>:</p><pre class="programlisting"><strong class="hl-keyword">function</strong>(doc)
{
    much javascript here
}</pre><p>The repository class:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@View( name = "complicated_view", map = "classpath:myMapFunction.js")</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getAverageSofaSize() {
    ViewResult r = db.queryView(createQuery(<strong class="hl-string"><em style="color:red">"complicated_view.json"</em></strong>));
    <strong class="hl-keyword">return</strong> r.getRows().get(<span class="hl-number">0</span>).getValueAsInt();
}</pre></div><div class="section" title="Auto Updating Views"><div class="titlepage"><div><div><h3 class="title"><a name="d100e795"></a>Auto Updating Views</h3></div></div></div><p>The default behaviour is to not touch existing views if they
        already exists. However, Ektorp can update views automatically if the
        view defined in the annotation @View differs from the one existing in
        the database. This is especially convenient during development.</p><p>This feature is enabled through the system property:
        <span class="emphasis"><em>org.ektorp.support.AutoUpdateViewOnChange=true</em></span></p><p>If enabled, a simple string comparison will determine if the
        view definition has changed and update it if necessary.</p><p>If you are using the Ektorp Spring module, you can also enable
        this feature through a setter in
        <span class="emphasis"><em>org.ektorp.spring.HttpClientFactoryBean</em></span>.</p></div></div><div class="section" title="Automatic Generation of Design Document and Views"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e811"></a>Automatic Generation of Design Document
      and Views</h2></div></div></div><p><span class="emphasis"><em>CouchDbRepositorySupport</em></span> is able to generate
      some views automatically. Simple finder methods can be annotated with
      the <span class="emphasis"><em>@GenererateView</em></span> annotation.</p><pre class="programlisting">...
<em><span class="hl-annotation" style="color: gray">@GenerateView</span></em>
<strong class="hl-keyword">public</strong> List&lt;Sofa&gt; findByColor(String color) {
    <strong class="hl-keyword">return</strong> queryView(<strong class="hl-string"><em style="color:red">"by_color"</em></strong>, color);
}
...</pre><p>In order for @GenerateView to work properly, the following
      requirements has to be fulfilled:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The method must be named findBy[Property]. If a
          @TypeDiscriminator is defined, the "all" view used by the getAll
          method can also be generated.</p></li><li class="listitem"><p>The method may only have one parameter.</p></li><li class="listitem"><p>The property must exist in the target class.</p><p><span class="emphasis"><em>public String getColor()</em></span> in the class
          Sofa the example above.</p></li><li class="listitem"><p>For iterable properties the property may be named in the
          plural form: <span class="emphasis"><em>List&lt;String&gt;
          getColors()</em></span></p></li></ul></div><p>The generated view will be named by_[property].</p><p>View generation is triggered by calling the method:
      <span class="emphasis"><em>initStandardDesignDocument</em></span> in
      <span class="emphasis"><em>CouchDbRepositorySupport</em></span>.</p><p>If the standard design document doesn't exists, it will be
      created.</p><div class="section" title="Resolving Field Name Conflicts"><div class="titlepage"><div><div><h3 class="title"><a name="d100e856"></a>Resolving Field Name Conflicts</h3></div></div></div><p>The database may contain other types of documents that have a
        field with the same name as in the type handled by a particular
        repository. This is normally not a problem, but if that field name is
        used as a key or in a condition in a view, wrong documents may be
        returned in view queries.</p><p>In order to distinguish your type's documents in the database
        the @TypeDiscriminator annotation can be used:</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> BlogPost {

    <em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
    <strong class="hl-keyword">private</strong> String id;

    <em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em>
    <strong class="hl-keyword">private</strong> String rev;

    <em class="hl-comment" style="color: silver">// this field marks blog post documents in the db </em>
    <em><span class="hl-annotation" style="color: gray">@TypeDiscriminator</span></em>
    <strong class="hl-keyword">private</strong> String title;

...</pre><p> It is also possible to write a custom type discriminator
        by declaring the @TypeDiscriminator on the type:</p><pre class="programlisting"><em class="hl-comment" style="color: silver">// the declared string is inserted as a part of if statements int the generated view's map function.</em>
<em><span class="hl-annotation" style="color: gray">@TypeDiscriminator("doc.title &amp;&amp; doc.myField === 'special_value'")</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> BlogPost {

    <em><span class="hl-annotation" style="color: gray">@JsonProperty("_id")</span></em>
    <strong class="hl-keyword">private</strong> String id;

    <em><span class="hl-annotation" style="color: gray">@JsonProperty("_rev")</span></em>
    <strong class="hl-keyword">private</strong> String rev

    <strong class="hl-keyword">private</strong> String title;

    <strong class="hl-keyword">private</strong> String myField;

...</pre></div></div><div class="section" title="Additional Design Document Functions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e868"></a>Additional Design Document Functions</h2></div></div></div><p>Repositories based on CouchDbRepositorySupport may also define
      list, show and filter functions through annotations in the repository
      class.</p><p>They all have the same functionality, it is just the type of
      function that differs:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Filter( name = "my_filter" file = "my_filter.js")</span></em>
<em><span class="hl-annotation" style="color: gray">@ListFunction( name = "my_list_function" file = "my_list_function.js")</span></em>
<em><span class="hl-annotation" style="color: gray">@ShowFunction( name = "my_show_function" file = "my_show_function.js")</span></em>
<em><span class="hl-annotation" style="color: gray">@UpdateHandler( name = "my_show_function" file = "my_update_handler.js")</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyRepository {
    ...</pre><p>Multiple functions can be grouped with the corresponding
      annotations @Filters, @Lists, @Shows and @UpdateHandlers.</p><p>These annotations behaves in effect as the @View and @Views
      annotations described in section 3 of this chapter.</p></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;Attachments"><div class="titlepage"><div><div><h2 class="title"><a name="d100e881"></a>Chapter&nbsp;7.&nbsp;Attachments</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e886">In-line Attachments</a></span></dt><dt><span class="section"><a href="#d100e895">Create Document and Attachment in one operation</a></span></dt><dt><span class="section"><a href="#d100e902">Add an Attachment to an Existing Document</a></span></dt><dt><span class="section"><a href="#d100e909">Fetch an Attachment</a></span></dt></dl></div><p>Documents in CouchDB may have any number of attachments associated
    with it. The content of an attachment is not loaded together with the
    document, just a stub containing meta information is co-loaded with the
    document.</p><div class="section" title="In-line Attachments"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e886"></a>In-line Attachments</h2></div></div></div><p>Attachments can be stored along with its parent document by
      embedding them in the parent document. The attachment itself has to be
      Base64 encoded in this case as the whole document including the
      attachment will be serialized into a string.</p><p>Note that the Sofa class in the example below extends
      CouchDbDocument and exposes the protected method
      addInlineAttachment(Attachment a).</p><pre class="programlisting">String base64EncodedData = ...
Sofa sofa = ...

Attachment inline = <strong class="hl-keyword">new</strong> Attachment(<strong class="hl-string"><em style="color:red">"attachment_id"</em></strong>, base64EncodedData, <strong class="hl-string"><em style="color:red">"image/jpeg"</em></strong>);

sofa.addInlineAttachment(inline);
db.update(sofa);</pre></div><div class="section" title="Create Document and Attachment in one operation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e895"></a>Create Document and Attachment in one operation</h2></div></div></div><p>An attachment and its parent document can be created in the same
      operation. This is useful if you just want to store the data "as is" and
      don't really use the actual document, i.e. when storing an image.</p><pre class="programlisting">InputStream data = ...
String contentType = <strong class="hl-string"><em style="color:red">"image/jpeg"</em></strong>;

AttachmentInputStream a = <strong class="hl-keyword">new</strong> AttachmentInputStream(<strong class="hl-string"><em style="color:red">"attachment_id"</em></strong>,
                                                     data,
                                                     contentType);

db.createAttachment(<strong class="hl-string"><em style="color:red">"new_document_id"</em></strong>, a);</pre></div><div class="section" title="Add an Attachment to an Existing Document"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e902"></a>Add an Attachment to an Existing Document</h2></div></div></div><p>If you don't want to add the attachment in-line, you can add
      attachments in an separate operation.</p><pre class="programlisting">AttachmentInputStream a = new AttachmentInputStream("attachment_id",
                                                     data,
                                                     contentType);

db.createAttachment("existing_document_id", "document_revision", a);</pre></div><div class="section" title="Fetch an Attachment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e909"></a>Fetch an Attachment</h2></div></div></div><p>To retrieve the attachment's content:</p><pre class="programlisting">AttachmentInputStream data = db.getAttachment(<strong class="hl-string"><em style="color:red">"document_id"</em></strong>,
                                              <strong class="hl-string"><em style="color:red">"attachment_id"</em></strong>);</pre><p>The entity base class
      <span class="emphasis"><em>org.ektorp.support.CouchDbDocument</em></span> provides an
      accessor for the document's attachments. The list contains stub
      attachments.</p></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Querying"><div class="titlepage"><div><div><h2 class="title"><a name="d100e921"></a>Chapter&nbsp;8.&nbsp;Querying</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e931">Query for Objects</a></span></dt><dt><span class="section"><a href="#d100e941">Scalar Queries</a></span></dt><dt><span class="section"><a href="#d100e954">View Result as Raw JSON Stream</a></span></dt><dt><span class="section"><a href="#d100e961">Complex Keys</a></span></dt><dt><span class="section"><a href="#d100e976">Pagination</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e991">PageRequest as a text link</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e1006">Queries and Cache</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1013">Enable the Cached Queries</a></span></dt></dl></dd></dl></div><p>Queries in Ektorp are always performed against predefined views in
    CouchDB. View queries are issued through
    <span class="emphasis"><em>org.ektorp.ViewQuery</em></span> objects.</p><pre class="programlisting">ViewQuery query = <strong class="hl-keyword">new</strong> ViewQuery()
                     .designDocId(<strong class="hl-string"><em style="color:red">"_design/Sofa"</em></strong>)
                     .viewName(<strong class="hl-string"><em style="color:red">"by_color"</em></strong>)
                     .key(<strong class="hl-string"><em style="color:red">"red"</em></strong>);</pre><div class="section" title="Query for Objects"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e931"></a>Query for Objects</h2></div></div></div><p>Objects can be loaded directly from view results as long as the
      result contain documents. The document can either be included in the
      view result by specifying the query parameter
      <span class="emphasis"><em>includeDocs(true)</em></span> or be emitted directly by the
      view into the value field.</p><pre class="programlisting">ViewQuery query = <strong class="hl-keyword">new</strong> ViewQuery()
                     .designDocId(<strong class="hl-string"><em style="color:red">"_design/Sofa"</em></strong>)
                     .viewName(<strong class="hl-string"><em style="color:red">"by_color"</em></strong>)
                     .key(<strong class="hl-string"><em style="color:red">"red"</em></strong>);
                
List&lt;Sofa&gt; redSofas = db.queryView(query, Sofa.<strong class="hl-keyword">class</strong>);</pre></div><div class="section" title="Scalar Queries"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e941"></a>Scalar Queries</h2></div></div></div><p>It is possible to query for scalar values.</p><pre class="programlisting">ViewQuery query = <strong class="hl-keyword">new</strong> ViewQuery()
          .designDocId(<strong class="hl-string"><em style="color:red">"_design/somedoc"</em></strong>)
          .viewName(<strong class="hl-string"><em style="color:red">"some_view_name"</em></strong>);
                
ViewResult result = db.queryView(query);
<strong class="hl-keyword">for</strong> (ViewResult.Row row : result.getRows()) {
    String stringValue = row.getValue();
    <strong class="hl-keyword">int</strong> intValue = row.getValueAsInt();
}</pre><p>The key, value and doc fields can be access as a
      <span class="emphasis"><em>org.jackson.JsonNode:</em></span></p><pre class="programlisting">
ViewResult result = db.queryView(query);
<strong class="hl-keyword">for</strong> (ViewResult.Row row : result) {
    JsonNode keyNode = row.getKeyAsNode();
    JsonNode valueNode = row.getValueAsNode();
    JsonNode docNode = row.getDocAsNode();
    ...
}</pre></div><div class="section" title="View Result as Raw JSON Stream"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e954"></a>View Result as Raw JSON Stream</h2></div></div></div><p>The most flexible method is query for stream. The result is
      returned as a stream. It is important that the stream is closed after
      usage as resource leaks otherwise will occur.</p><pre class="programlisting">ViewQuery query = <strong class="hl-keyword">new</strong> ViewQuery()
                       .designDocId(<strong class="hl-string"><em style="color:red">"_design/somedoc"</em></strong>)
                       .viewName(<strong class="hl-string"><em style="color:red">"view_with_huge_result"</em></strong>);

InputStream data = db.queryForStream(query);
...
data.close();</pre></div><div class="section" title="Complex Keys"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e961"></a>Complex Keys</h2></div></div></div><p>If your views produce complex keys such as [2010, 6, 1], you
      should construct your key through the class
      <span class="emphasis"><em>org.ektorp.ComplexKey</em></span></p><pre class="programlisting">ComplexKey start = ComplexKey.of(<span class="hl-number">2010</span>, <span class="hl-number">6</span>, <span class="hl-number">1</span>);
ComplexKey end = ComplexKey.of(<span class="hl-number">2010</span>, <span class="hl-number">10</span>, <span class="hl-number">1</span>);
        
ViewQuery query = <strong class="hl-keyword">new</strong> ViewQuery()
                       .designDocId(<strong class="hl-string"><em style="color:red">"_design/Order"</em></strong>)
                       .viewName(<strong class="hl-string"><em style="color:red">"by_orderDate"</em></strong>)
                       .startKey(start)
                       .endKey(end);</pre><p>If you want to use a wild
      card in your key, often used in date ranges, add a
      <span class="emphasis"><em>ComplexKey.emptyObject()</em></span>:</p><pre class="programlisting">    <em class="hl-comment" style="color: silver">// will render to [2010, {}]</em>
    ComplexKey allOf2<span class="hl-number">010</span> = ComplexKey.of(<span class="hl-number">2010</span>, ComplexKey.emptyObject());</pre></div><div class="section" title="Pagination"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e976"></a>Pagination</h2></div></div></div><p>CouchDbConnector provides a method for querying views for paged
      results. The implementation is based on the recipe described in the book
      <a class="link" href="http://guide.couchdb.org/editions/1/en/recipes.html#pagination" target="_top">"CouchDB
      The Definitive Guide"</a></p><p>Querying a view for a page starts with the querying for the first
      page:</p><pre class="programlisting"><em class="hl-comment" style="color: silver">// create a page request with a page size of 5 </em>
PageRequest pageRequest = PageRequest.firstPage(<span class="hl-number">5</span>);

ViewQuery query = <strong class="hl-keyword">new</strong> ViewQuery()
                       .designDocId(<strong class="hl-string"><em style="color:red">"_design/Order"</em></strong>)
                       .viewName(<strong class="hl-string"><em style="color:red">"by_orderDate"</em></strong>)
                       .includeDocs(true);

Page&lt;Order&gt; result = db.queryForPage(query, pageRequest, Order.<strong class="hl-keyword">class</strong>);

<em class="hl-comment" style="color: silver">// Page is iterable</em>
<strong class="hl-keyword">for</strong> (Order o : result) {
    <em class="hl-comment" style="color: silver">// do something here</em>
}</pre><p><em class="parameter"><code>Requesting the next page is a simple
      affair:</code></em></p><pre class="programlisting">Page&lt;Order&gt; previousPage = ...
PageRequest nextPageRequest = previousPage.getNextPageRequest();

Page&lt;Order&gt; nextPage = db.queryForPage(query, nextPageRequest, Order.<strong class="hl-keyword">class</strong>);

<em class="hl-comment" style="color: silver">// requesting the previous page:</em>
PageRequest prevPageRequest = nextPage.getPreviousPageRequest();</pre><div class="section" title="PageRequest as a text link"><div class="titlepage"><div><div><h3 class="title"><a name="d100e991"></a>PageRequest as a text link</h3></div></div></div><p>In order to simplify state handling between separate http
        requests the page request can be serialized into an URL-safe
        string.</p><p>Given that the Page object is available in the model in the jsp
        page below, a link to the previous page can be constructed like
        this:</p><pre class="programlisting">&lt;c:if test="${page.hasPrevious}"&gt;
    &lt;a href="/blog/posts/?p=${page.previousLink}"&gt;Previous page&lt;/a&gt;
&lt;/c:if&gt;</pre><p>When the request is handled in a controller the page request can
        be recreated from the request parameter. Here is an example snippet
        from a controller created in Spring MVC</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@RequestMapping( value = "/posts/", method = RequestMethod.GET)</span></em>
<strong class="hl-keyword">public</strong> String viewAll(Model m, <em><span class="hl-annotation" style="color: gray">@RequestParam(value = "p", required = false)</span></em> String pageLink) {
    PageRequest pr = pageLink != null ? PageRequest.fromLink(pageLink) : PageRequest.firstPage(<span class="hl-number">5</span>);
    m.addAttribute(blogPostRepo.getAll(pr));
    <strong class="hl-keyword">return</strong> <strong class="hl-string"><em style="color:red">"/posts/index"</em></strong>;
}</pre><p>Handlig the page state as text links eliminates the need for
        storing data in the session.</p></div></div><div class="section" title="Queries and Cache"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1006"></a>Queries and Cache</h2></div></div></div><p>If you enable the cache in a query, the result may be stale
      depending on how your view is constructed.</p><p>The cache works through conditional gets that invalidates the
      cache if the view's etag has changed. It is possible that an document
      update don't cause the view contents to be updated and hence the cache
      will not be invalidated. If you emit a timestamp or the document's
      revision as the view value the cache will be properly
      invalidated.</p><div class="section" title="Enable the Cached Queries"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1013"></a>Enable the Cached Queries</h3></div></div></div><p>As of Ektorp 1.2.2 it is possible to control if a query should
        use the cache or not. Cached queries is disabled by default but can be
        enabled by setting the parameter cacheOk to true in ViewQuery.</p></div></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Change Notifications"><div class="titlepage"><div><div><h2 class="title"><a name="d100e1018"></a>Chapter&nbsp;9.&nbsp;Change Notifications</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e1039">Continuous changes</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1051">Managing the Feed</a></span></dt></dl></dd><dt><span class="section"><a href="#d100e1058">Snapshots</a></span></dt></dl></div><p>As of Ektorp 1.1.0 the <a class="link" href="http://wiki.apache.org/couchdb/HTTP_database_API#Changes" target="_top">CouchDB
    changes API</a> is supported.</p><p>Ektorp provides two different methods to access the database
    changes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Continuous changes feed enables your application to listen to
        change events as they happen in the database in real time.</p></li><li class="listitem"><p>Snapshots that provides all changes since a specific database
        sequence number.</p></li></ul></div><p>Both methods are specified through a ChangesCommand:</p><pre class="programlisting">ChangesCommand cmd = <strong class="hl-keyword">new</strong> ChangesCommand.Builder()
                             .includeDocs(true)
                             .build();</pre><div class="section" title="Continuous changes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1039"></a>Continuous changes</h2></div></div></div><p>Ektorp provides a continuous changes feed through the class
      <span class="emphasis"><em>org.ektorp.changes.ChangesFeed</em></span>. The ChangesFeed
      provides an API that is similar to a BlockingQueue:</p><pre class="programlisting">ChangesCommand cmd = <strong class="hl-keyword">new</strong> ChangesCommand.Builder().build();

ChangesFeed feed = db.changesFeed(cmd);

<strong class="hl-keyword">while</strong> (feed.isAlive()) {
    DocumentChange change = feed.next();
    String docId = change.getId();
    ...
}
</pre><p>If you don't want to wait indefinitely for changes the ChangesFeed
      class provides a variant if the feed method where a time out can be
      specified.</p><div class="section" title="Managing the Feed"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1051"></a>Managing the Feed</h3></div></div></div><p>As long as the feed is alive it will continue to buffer changes
        coming from the database. This will happen regardless if any thread is
        draing the feed though calls to next(). This means that your
        application might experience OutOfMemoryError if a feed is left
        unattended.</p><p>To kill a feed just call the cancel() method provided by the
        ChangesFeed class.</p></div></div><div class="section" title="Snapshots"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1058"></a>Snapshots</h2></div></div></div><p>If continuous notifications are not needed, the database can be
      queried through the <span class="emphasis"><em>changes</em></span> method in
      CouchDbConnector:</p><pre class="programlisting"><strong class="hl-keyword">int</strong> dbSequenceNumber = ... <em class="hl-comment" style="color: silver">// is available in the class org.ektorp.DbInfo obtained through db.getDbInfo();</em>

ChangesCommand cmd = <strong class="hl-keyword">new</strong> ChangesCommand.Builder()
                         .since(dbSequenceNumber)
                         .build();

List&lt;DocumentChange&gt; changes = db.changes(cmd);
<strong class="hl-keyword">for</strong>(DocumentChange change : changes) {
    ...
}</pre></div></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Calling Update Handlers"><div class="titlepage"><div><div><h2 class="title"><a name="d100e1068"></a>Chapter&nbsp;10.&nbsp;Calling Update Handlers</h2></div></div></div><p>CouchDB provides the ability to define functions that clients can
    request to invoke server-side logic that will create or update a
    document.</p><p>CouchDbConnector provides a method for calling update
    handlers:</p><pre class="programlisting">CouchDbConnector db = ...
String responseString = db.callUpdateHandler(<strong class="hl-string"><em style="color:red">"_design/designDocID"</em></strong>, <strong class="hl-string"><em style="color:red">"functionName"</em></strong>, <strong class="hl-string"><em style="color:red">"docID"</em></strong>);</pre></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;Admin Functions"><div class="titlepage"><div><div><h2 class="title"><a name="d100e1077"></a>Chapter&nbsp;11.&nbsp;Admin Functions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e1081">Database Replication</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1097">Initiate Replication from CouchDbInstance</a></span></dt><dt><span class="section"><a href="#d100e1115">Initiate Replication from CouchDbConnector</a></span></dt></dl></dd></dl></div><p></p><div class="section" title="Database Replication"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1081"></a>Database Replication</h2></div></div></div><p>Database replication can be initiated through in two ways:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>The replicate method in
          <span class="emphasis"><em>CouchDbInstance.</em></span></p></li><li class="listitem"><p>The replicateTo and replicateFrom methods in
          <span class="emphasis"><em>CouchDbConnector.</em></span></p></li></ul></div><div class="section" title="Initiate Replication from CouchDbInstance"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1097"></a>Initiate Replication from CouchDbInstance</h3></div></div></div><p>The replication job is defined in the class
        <span class="emphasis"><em>org.ektorp.ReplicationCommand</em></span>. The command is
        created by its companion builder class:
        <span class="emphasis"><em>org.ektorp.ReplicationCommand.Builder</em></span>:</p><pre class="programlisting">CouchDbInstance dbInstance = ...

ReplicationCommand cmd = <strong class="hl-keyword">new</strong> ReplicationCommand.Builder()
                                 .source(<strong class="hl-string"><em style="color:red">"example-database"</em></strong>)
                                 .target(<strong class="hl-string"><em style="color:red">"http://example.org/example-database"</em></strong>)
                                 .build();

ReplicationStatus status = dbInstance.replicate(cmd);</pre><p>ReplicationCommand supports all replication parameters defined
        in the <a class="link" href="http://wiki.apache.org/couchdb/Replication" target="_top">CouchDb
        reference documentation</a>.</p></div><div class="section" title="Initiate Replication from CouchDbConnector"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1115"></a>Initiate Replication from CouchDbConnector</h3></div></div></div><p>Replications can be initiated from a
        <span class="emphasis"><em>CouchDbConnector</em></span>, in this case one database
        involved in the replication is the database the
        <span class="emphasis"><em>CouchDbConnector</em></span> is connected to.</p><pre class="programlisting">CouchDbConnector db = ...

ReplicationStatus status = db.replicateFrom(<strong class="hl-string"><em style="color:red">"example-database"</em></strong>);

<em class="hl-comment" style="color: silver">// or</em>

ReplicationStatus status2 = db.replicateTo(<strong class="hl-string"><em style="color:red">"http://example.org/example-database"</em></strong>);</pre><p>The methods in <span class="emphasis"><em>CouchDbConnector</em></span> will start
        basic one time replications, for more advanced options use the
        replicate method in <span class="emphasis"><em>CouchDbInstance</em></span>.</p></div></div></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;Spring Integration"><div class="titlepage"><div><div><h2 class="title"><a name="d100e1136"></a>Chapter&nbsp;12.&nbsp;Spring Integration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e1140">XML Schema-based configuration</a></span></dt><dt><span class="section"><a href="#d100e1157">HttpClientFactoryBean</a></span></dt><dt><span class="section"><a href="#d100e1170">Bootstrapping the Database</a></span></dt><dd><dl><dt><span class="section"><a href="#d100e1183">Declaing the InitialDataLoader in the Application
        Context</a></span></dt><dt><span class="section"><a href="#d100e1190">Component Scanning</a></span></dt><dt><span class="section"><a href="#d100e1200">DataLoader</a></span></dt></dl></dd></dl></div><p></p><div class="section" title="XML Schema-based configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1140"></a>XML Schema-based configuration</h2></div></div></div><p>Ektorp Spring module comes with a Spring XML namespace that
      simplifies the Ektorp configuration in an application context.</p><p>The following xml-snippet will create an CouchDbConnector
      connected to the database named "myDatabase". If an id is not declared
      the connector will be registered with the same id as the database name
      in the application context:</p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: #000096">&lt;beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:couchdb</span>=<span class="hl-value" style="color: #993300">"http://www.ektorp.org/schema/couchdb"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.ektorp.org/schema/couchdb http://www.ektorp.org/schema/couchdb/couchdb.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;couchdb:database</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myDatabase"</span> <span class="hl-attribute" style="color: #F5844C">url</span>=<span class="hl-value" style="color: #993300">"http://localhost:5984"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans&gt;</strong></pre><p>If you need multiple connectors connected to
      the same CouchDB instance, the CouchDbInstance bean can be explicitly
      declared:</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:couchdb</span>=<span class="hl-value" style="color: #993300">"http://www.ektorp.org/schema/couchdb"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.ektorp.org/schema/couchdb http://www.ektorp.org/schema/couchdb/couchdb.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;couchdb:instance</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"localCouchDB"</span> <span class="hl-attribute" style="color: #F5844C">url</span>=<span class="hl-value" style="color: #993300">"http://localhost:5984/"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;couchdb:database</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myDatabase"</span> <span class="hl-attribute" style="color: #F5844C">instance-ref</span>=<span class="hl-value" style="color: #993300">"localCouchDB"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;couchdb:database</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myOtherDatabase"</span> <span class="hl-attribute" style="color: #F5844C">instance-ref</span>=<span class="hl-value" style="color: #993300">"localCouchDB"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans&gt;</strong></pre><p><em class="parameter"><code>If you need to specify more
      properties to Ektorp you can just refer to them when the CouchDB
      instance is declared:</code></em></p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;beans</strong> <span class="hl-attribute" style="color: #F5844C">xmlns</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:xsi</span>=<span class="hl-value" style="color: #993300">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:couchdb</span>=<span class="hl-value" style="color: #993300">"http://www.ektorp.org/schema/couchdb"</span>
    <span class="hl-attribute" style="color: #F5844C">xmlns:util</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/util"</span>
    <span class="hl-attribute" style="color: #F5844C">xsi:schemaLocation</span>=<span class="hl-value" style="color: #993300">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.ektorp.org/schema/couchdb http://www.ektorp.org/schema/couchdb/couchdb.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd"</span><strong class="hl-tag" style="color: #000096">&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;util:properties</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"couchdbProperties"</span> <span class="hl-attribute" style="color: #F5844C">location</span>=<span class="hl-value" style="color: #993300">"classpath:/couchdb.properties"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;couchdb:instance</strong> <span class="hl-attribute" style="color: #F5844C">id</span>=<span class="hl-value" style="color: #993300">"localCouchDB"</span> <span class="hl-attribute" style="color: #F5844C">url</span>=<span class="hl-value" style="color: #993300">"http://localhost:5984"</span> <span class="hl-attribute" style="color: #F5844C">properties</span>=<span class="hl-value" style="color: #993300">"couchdbProperties"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

    <strong class="hl-tag" style="color: #000096">&lt;couchdb:database</strong> <span class="hl-attribute" style="color: #F5844C">name</span>=<span class="hl-value" style="color: #993300">"myDatabase"</span> <span class="hl-attribute" style="color: #F5844C">instance-ref</span>=<span class="hl-value" style="color: #993300">"localCouchDB"</span><strong class="hl-tag" style="color: #000096"> /&gt;</strong>

<strong class="hl-tag" style="color: #000096">&lt;/beans&gt;</strong></pre></div><div class="section" title="HttpClientFactoryBean"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1157"></a>HttpClientFactoryBean</h2></div></div></div><p>If you for some reason cannot use the XML namespace described in
      the previous section, you can use the class
      org.ektorp.spring.HttpClientFactoryBean to configure a HttpClient in the
      application context.</p><p>When added to the appllication context, the factory will read
      configuration from couchdbProperties defined in the application
      context:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:util="http://www.springframework.org/schema/util"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;

    &lt;util:properties id="couchdbProperties" location="classpath:/couchdb.properties"/&gt;

    &lt;bean id="httpClient" class="org.ektorp.spring.HttpClientFactoryBean" /&gt;

    &lt;bean id="couchDbInstance" class="org.ektorp.impl.StdCouchDbInstance"&gt;
        &lt;constructor-arg ref="httpClient"/&gt;
    &lt;/bean&gt;

    &lt;bean id="initialDataLoader" class="org.ektorp.spring.InitialDataLoader" autowire="byType" init-method="loadData"/&gt;

&lt;/beans&gt;</pre><p>And here is a couchdb.properties to cut &amp; paste:</p><pre class="programlisting">host=localhost
port=5984
maxConnections=20
connectionTimeout=1000
socketTimeout=10000
username=CouchDB_Admin
password=geheimnis</pre></div><div class="section" title="Bootstrapping the Database"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1170"></a>Bootstrapping the Database</h2></div></div></div><p>The Ektorp Spring module features a class for loading the database
      with documents at application startup.</p><p>The <span class="emphasis"><em>org.ektorp.spring.InitialDataLoader</em></span> will
      lookup all beans in the application context that implements
      <span class="emphasis"><em>org.ektorp.dataload.DataLoader</em></span> (typically your
      repositories) and feed them data streams loaded from locations specified
      by the DataLoaders themselves.</p><div class="section" title="Declaing the InitialDataLoader in the Application Context"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1183"></a>Declaing the InitialDataLoader in the Application
        Context</h3></div></div></div><p>The InitialDataLoader work best if its dependencies are
        autowired. (Otherwise you will have to maintain the list of
        DataLoaders manually).</p><pre class="programlisting"><strong class="hl-tag" style="color: #000096">&lt;bean</strong> <span class="hl-attribute" style="color: #F5844C">class</span>=<span class="hl-value" style="color: #993300">"org.ektorp.spring.InitialDataLoader"</span> <span class="hl-attribute" style="color: #F5844C">autowire</span>=<span class="hl-value" style="color: #993300">"constructor"</span><strong class="hl-tag" style="color: #000096">/&gt;</strong></pre></div><div class="section" title="Component Scanning"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1190"></a>Component Scanning</h3></div></div></div><p>The InitialDataLoader will be created automatically if you
        include the <span class="emphasis"><em>org.ektorp.spring</em></span> package in your
        component scan directive:</p><pre class="programlisting">&lt;context:component-scan base-package="org.example"&gt;
    &lt;context:include-filter type="regex" expression="org\.ektorp\.spring.*"/&gt;
&lt;/context:component-scan&gt;</pre></div><div class="section" title="DataLoader"><div class="titlepage"><div><div><h3 class="title"><a name="d100e1200"></a>DataLoader</h3></div></div></div><p>The dataloader points out its data locations through the method
        String[] getDataLocations(). The location is loaded though Spring's
        <a class="link" href="http://static.springsource.org/spring/docs/3.0.x/spring-framework-reference/html/resources.html" target="_top">resource
        loader</a> so paths like
        <span class="emphasis"><em>"classpath:/my_initial_docs.json"</em></span> are expected.
        The DataLoader can then process the data in the loadInitialData
        method.</p><pre class="programlisting"><strong class="hl-keyword">import</strong> org.ektorp.dataload.*;
<strong class="hl-keyword">import</strong> org.ektorp.support.*;

<strong class="hl-keyword">class</strong> SofaRepository <strong class="hl-keyword">extends</strong> CouchDbRepositorySupport&lt;Sofa&gt; <strong class="hl-keyword">implements</strong> DataLoader {

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">final</strong> <strong class="hl-keyword">static</strong> String[] INITIAL_DATA_PATH = {<strong class="hl-string"><em style="color:red">"classpath:/init_sofa_data.json"</em></strong>};

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> loadInitialData(Reader in) {
        <strong class="hl-keyword">new</strong> DefaultDataLoader(db).load(in);
    }
  
    <strong class="hl-keyword">public</strong> String[] getDataLocations() {
        <strong class="hl-keyword">return</strong> INITIAL_DATA_PATH;
    }

    <strong class="hl-tag" style="color: blue">/**
    * Is called when all DataLoaders in the system has loaded it&acute;s data.
    */</strong>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> allDataLoaded() {

    }
}</pre></div></div></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Android Integration"><div class="titlepage"><div><div><h2 class="title"><a name="d100e1213"></a>Chapter&nbsp;13.&nbsp;Android Integration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#d100e1218">AndroidHttpClient</a></span></dt><dt><span class="section"><a href="#d100e1236">EktorpAsyncTask</a></span></dt><dt><span class="section"><a href="#d100e1251">ChangesFeedAsyncTask</a></span></dt><dt><span class="section"><a href="#d100e1265">CouchbaseViewListAdapter</a></span></dt></dl></div><p>The Android Integration package provides additional functionality to
    improve the behavior of Ektorp on the Android Platform. Using the
    AndroidHttpClient implementation is required since Android inclues a
    version of Apache HttpClient that is not compatible with the StdHttpClient
    provided by Ektorp. Use of the other classes in this package is entirely
    optional, but they may save you writing repetitive code.</p><div class="section" title="AndroidHttpClient"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1218"></a>AndroidHttpClient</h2></div></div></div><p>Ektorp has a custom implementation of the HttpClient interface for
      Android <span class="emphasis"><em>org.ektorp.android.http.AndroidHttpClient</em></span>.
      It is designed to use the version of Apache HttpClient included in the
      Android platform:
      <span class="emphasis"><em>AnddroidHttpClient.Builder</em></span></p><pre class="programlisting">HttpClient authenticatedHttpClient = <strong class="hl-keyword">new</strong> AndroidHttpClient.Builder()
                                .url(<strong class="hl-string"><em style="color:red">"http://mychouchdbhost:5984"</em></strong>)
                                .username(<strong class="hl-string"><em style="color:red">"admin"</em></strong>)
                                .password(<strong class="hl-string"><em style="color:red">"secret"</em></strong>)
                                .build();</pre><p>When using AndroidHttpClient you should NOT include the httpclient
      or httpcore libraries in your project. Android includes a copy of Apache
      HttpClient and supplying your own copy can lead to difficult to debug
      class loading exceptions.</p><p><span class="emphasis"><em>NOTE:</em></span> AndroidHttpClient does not support
      caching.</p></div><div class="section" title="EktorpAsyncTask"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1236"></a>EktorpAsyncTask</h2></div></div></div><p>The EktorpAsyncTask class extends the Android platform's <a class="link" href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_top">AsyncTask</a>
      class to perform Ektorp operations on a background thread, while
      handling success and failure conditions on the application's main
      thread. This is important since performing network operations on the
      main thread may lead to <a class="link" href="http://developer.android.com/reference/android/os/NetworkOnMainThreadException.html" target="_top">
      NetworkOnMainThreadException</a>. Further, you can only interact with
      the Android UI from the main thread.</p></div><pre class="programlisting">EktorpAsyncTask createItemTask = <strong class="hl-keyword">new</strong> EktorpAsyncTask() {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">void</strong> doInBackground() {
        couchDbConnector.create(item);
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">void</strong> onSuccess() {
        Toast.makeText(context, <strong class="hl-string"><em style="color:red">"Document created successfully"</em></strong>, <span class="hl-number">5000</span>).show();
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">void</strong> onUpdateConflict(UpdateConflictException updateConflictException) {
        Toast.makeText(context, <strong class="hl-string"><em style="color:red">"Got an update conflict for: "</em></strong> + item.toString(), <span class="hl-number">5000</span>).show();
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">void</strong> onDbAccessException(DbAccessException dbAccessException) {
        Log.e(TAG, <strong class="hl-string"><em style="color:red">"DbAccessException in background"</em></strong>, dbAccessException);
    }
};
createItemTask.execute();
      </pre><p>In this example, a document is created on a background thread. If
    the document is created successfully or an update conflict occurs, the
    user is notifed by a Toast popup message. If any other DbAccessException
    occurs the exception is sent to the Android Log.</p><div class="section" title="ChangesFeedAsyncTask"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1251"></a>ChangesFeedAsyncTask</h2></div></div></div><p>The ChangesFeedAsyncTask is another class extending the Android
      platform's <a class="link" href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_top">AsyncTask</a>
      class. This class allows you to follow a CouchDB changes feed in a
      background thread and receive the DocumentChange objects on the main
      thread.</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> ExampleChangesFeedAsyncTask <strong class="hl-keyword">extends</strong> ChangesFeedAsyncTask {

    <strong class="hl-keyword">private</strong> Context context;

    <strong class="hl-keyword">public</strong> ExampleChangesFeedAsyncTask(Context context, CouchDbConnector couchDbConnector, ChangesCommand changesCommand) {
        <strong class="hl-keyword">super</strong>(couchDbConnector, changesCommand);
        <strong class="hl-keyword">this</strong>.context = context;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">void</strong> handleDocumentChange(DocumentChange change) {
        Toast.makeText(context, <strong class="hl-string"><em style="color:red">"Received change sequence : "</em></strong> + change.getSequence(), <span class="hl-number">5000</span>).show();
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">void</strong> onDbAccessException(DbAccessException dbAccessException) {
        Log.e(TAG, <strong class="hl-string"><em style="color:red">"DbAccessException following changes feed"</em></strong>, dbAccessException);
    }

}</pre><p>Then to use this class:</p><pre class="programlisting">ChangesCommand changesCmd = <strong class="hl-keyword">new</strong> ChangesCommand.Builder().since(lastUpdate).continuous(true).build();
ExampleChangesFeedAsyncTask couchChangesAsyncTask = <strong class="hl-keyword">new</strong> ExampleChangesFeedAsyncTask(couchDbConnector, changesCmd);
couchChangesAsyncTask.execute();
    </pre></div><div class="section" title="CouchbaseViewListAdapter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d100e1265"></a>CouchbaseViewListAdapter</h2></div></div></div><p>The CouchbaseViewListAdapter class extends the Android platform's
      <a class="link" href="http://developer.android.com/reference/android/widget/BaseAdapter.html" target="_top">BaseAdapter</a>
      class. This class allows you populate the rows of an Android <a class="link" href="http://developer.android.com/reference/android/widget/ListView.html" target="_top">ListView</a>.
      with content from the rows of a CouchDB view. Optionally, you can have
      it follow the changes feed and update the list when the data
      changes.</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> ExampleListAdapter <strong class="hl-keyword">extends</strong> CouchbaseViewListAdapter {

    <strong class="hl-keyword">private</strong> Context context;

    <strong class="hl-keyword">public</strong> ExampleListAdapter(Context context, CouchDbConnector couchDbConnector, ViewQuery viewQuery, <strong class="hl-keyword">boolean</strong> followChanges) {
        <strong class="hl-keyword">super</strong>(couchDbConnector, viewQuery, followChanges);
        <strong class="hl-keyword">this</strong>.context = context;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> View getView(<strong class="hl-keyword">int</strong> position, View itemView, ViewGroup parent) {
        <strong class="hl-keyword">if</strong> (itemView == null) {
            LayoutInflater li = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            itemView = li.inflate(R.layout.grocery_list_item, null);
        }

        TextView label = (TextView) itemView.findViewById(R.id.label);
        Row row = getRow(position);
        JsonNode item = row.getValueAsNode();
        JsonNode itemText = item.get(<strong class="hl-string"><em style="color:red">"text"</em></strong>);
        <strong class="hl-keyword">if</strong>(itemText != null) {
            label.setText(itemText.getTextValue());
        }

        <strong class="hl-keyword">return</strong> itemView;
    }
}
    </pre><p>To use this adapter:</p><pre class="programlisting">ViewQuery viewQuery = <strong class="hl-keyword">new</strong> ViewQuery().designDocId(dDocId).viewName(viewName);
ExampleListAdapter itemListViewAdapter = <strong class="hl-keyword">new</strong> ExampleListAdapter(<strong class="hl-keyword">this</strong>, couchDbConnector, viewQuery, true);
listView.setAdapter(itemListViewAdapter);
    </pre></div></div></div></body></html>